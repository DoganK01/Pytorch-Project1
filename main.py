"""Pytorch Project1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bQOJOxWAHML7i1Y2TBbpjITVSajARQgq
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
import os
import time

def read_images(path, num_of_img):
  array = np.zeros([num_of_img, 64*32])
  i=0
  for img in os.listdir(path):
    img_path = path + "\\" + img
    img = Image.open(img_path, mode = "r")
    data = np.asarray(img, dtype="uint8")
    data = data.flatten() #64x32 lik bir matrisi (resmi) 1x2048 lik bir vektöre çevirir. Çünkü bunları array de depolamak istiyoruz
    array[i,:] = data
    i += 1
  return array

train_neg_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Train\neg" #read yapmak istediğimiz için başına r koyuyoruz.
num_train_neg_img = 43390
train_neg_array = read_images(train_neg_path, num_train_neg_img)

input_train_neg_tensor = torch.from_numpy(train_neg_array)
print("İnput(test)(neg) size:" ,input_train_neg_tensor.size())

label_train_neg_tensor = torch.zeros(num_train_neg_img, dtype=torch.long) #neg sınıfının label'ı 0 oldu.
print("label (output)(test)(neg) size:", label_train_neg_tensor.size())

train_positive_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Train\pos" #read yapmak istediğimiz için başına r koyuyoruz.
num_train_positive_img = 43390
train_positive_array = read_images(train_positive_path, num_train_positive_img)

input_train_positive_tensor = torch.from_numpy(train_positive_array)
print("İnput(test)(positive) size:" ,input_train_positive_tensor.size())

label_train_positive_tensor = torch.ones(num_train_positive_img, dtype=torch.long) #positive sınıfının label'ı 1 oldu.
print("label (output)(test)(positive) size:", label_train_positive_tensor.size())

x_train = torch.cat((input_train_neg_tensor, input_train_positive_tensor),0) # 1 yapsaydı sütunları birleştirirdi.
y_train = torch.cat((label_train_neg_tensor, label_train_positive_tensor),0)

test_neg_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Test\neg" #read yapmak istediğimiz için başına r koyuyoruz.
num_test_neg_img = 22050
test_neg_array = read_images(test_neg_path, num_test_neg_img)
input_test_neg_tensor = torch.from_numpy(test_neg_array)
label_test_neg_tensor = torch.zeros(num_test_neg_img, dtype=torch.long) #neg sınıfının label'ı 0 oldu.





test_positive_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Test\pos" #read yapmak istediğimiz için başına r koyuyoruz.
num_test_positive_img = 5944
test_positive_array = read_images(test_positive_path, num_test_positive_img)
input_test_positive_tensor = torch.from_numpy(test_positive_array)
label_test_positive_tensor = torch.ones(num_test_positive_img, dtype=torch.long) #positive sınıfının label'ı 1 oldu.



x_test = torch.cat((input_test_neg_tensor, input_test_positive_tensor),0) # 1 yapsaydı sütunları birleştirirdi.
y_test = torch.cat((label_test_neg_tensor, label_test_positive_tensor),0)

num_epochs = 5000
num_classes = 2
batch_size = 8933
learning_rate = 0.00001

class Net(nn.Module):

  def __init__(self, block, layers, num_classes = num_classes):
    super(Net,self).__init__()

    self.conv1 = nn.Conv2d(1,10,5)
    self.pool = nn.MaxPool2d(2,2)
    self.conv2 = nn.Conv2d(10,16,5)

    self.fc1 = nn.Linear(16*13*5,520) 
    self.fc2 = nn.Linear(520,130)
    self.fc3 = nn.Linear(130, num_classes)

  def forward(self, input):
    
    input = self.pool(F.relu((self.conv1(input))))
    input = self.pool(F.relu((self.conv2(input))))


    input = input.view(-1, 16*13*5) # Flatten() kısmı #-1 yazmamızın nedeni, ne yazmamız gerektiğini bilmitoruz. O hesaplayıp kendisi yazıyor.
    input = F.relu(self.fc1(input))
    input = F.relu(self.fc2(input))
    input = self.fc3(input)

    return input

import torch.utils.data

train = torch.utils.data.TensorDataset(x_train, y_train) #birleştirme
trainloader = torch.utils.data.DataLoader(train, batch_size = batch_size, shuffle = True) #dataya çeviriyoruz

test = torch.utils.data.TensorDataset(x_test, y_test)
testloader = torch.utils.data.DataLoader(test, batch_size = batch_size, shuffle = False)

net = Net().to(device) #GPU için
net = Net()
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr = learning_rate, momentum = 0.8)

#Train network

start = time.time()


train_acc =[]
test_acc=[]
lost_list=[]



for epoch in range(num_epochs):
  for i, data in enumerate(trainloader, 0): #data nın içinde resimler ve label lar var.
    inputs, labels = data
    inputs = inputs.view(batch_size, 1, 64, 32) #color channel is 1 #reshape
    inputs = inputs.float()

    #ağırlıkları sıfırlama
    optimizer.zero_grad() #türevler adım başı sıfırlanır.

    #forward
    outputs = net(inputs)
    #Loss
    loss = criteriton(outputs, labels)
    #back
    loss.backward()
    #update parameters
    optimizer.step()


  #Test
  correct = 0
  total = 0
  with torch.no_grad():
    for data in testloader:
      images, labels = data
      images = images.view(batch_size,1,64,32)
      images = images.float()


      outputs = net(images)
      predicted = torch.max(outputs.data,1)

      total += labels.size(0)

      correct += (predicted == labels).sum().item() #doğruysa true döner ve toplanır

  acc1 = 100*(correct/total)
  print("accuracy test: ", acc1)
  test_acc.append(acc1)




  #Train
  correct = 0
  total = 0
  with torch.no_grad():
    for data in trainloader:
      images, labels = data
      images = images.view(batch_size,1,64,32)
      images = images.float()


      outputs = net(images)
      predicted = torch.max(outputs.data,1)

      total += labels.size(0)

      correct += (predicted == labels).sum().item() #doğruysa true döner ve toplanır

  acc2 = 100*(correct/total)
  print("accuracy train: ", acc2)
  test_acc.append(acc2)





    








end =time.time()

process_time = (end-start)/60 

print("process time ", process_time)
